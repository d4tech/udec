'use strict';

xdescribe('Unit: CryptoMan basic Functionalities', function() {
	var CryptoMan,
		passKey,
		globalIV,
		Wrangler,
		http;

	beforeEach(function() {
		module('udecApp');

		inject(function($injector) {
				passKey = $injector.get('passKey');
			    CryptoMan = $injector.get('CryptoMan');
			    globalIV = $injector.get('globalIV');
			    Wrangler = $injector.get('Wrangler');
			    // http = $injector.get($http);
			}
		);
	});

	xit('Should Initialize', function() {
		expect(angular.isFunction(CryptoMan.getRand)).toBeTruthy();
		expect(angular.isFunction(CryptoMan.setKey)).toBeTruthy();
		expect(angular.isFunction(CryptoMan.encrypt)).toBeTruthy();
		expect(angular.isFunction(CryptoMan.decrypt)).toBeTruthy();
	});

	xit('CryptoMan.getRand should return some Random value', function () {
		expect(CryptoMan.getRand()).not.toBeUndefined();
	});

	xit('CryptoMan.setKey should return some Value', function() {
		expect(CryptoMan.setKey()).not.toBeUndefined();
	});

	xdescribe('Checks for stringify',function () {
	    it('Should return an object', function () {
	        expect(typeof CryptoMan.stringify(CryptoJS.AES.encrypt('Some Message', 'some Key'))).toBe(typeof {});
	    });

		xit('Should return the Correct data', function () {
		    expect(CryptoMan.stringify(
		      CryptoJS.AES.encrypt('Some Message', 'some key')
		    )).toEqual(JSON.parse('{"ct":"0e689437404192dc6c0b563e18bc48d8","iv":"f02f265e2f98f7889aa97898943726ee","s":"910d20bab84380fc"}'));
		});
    });

    xdescribe('Checks for parse', function () {
      	it('Should return an Object for passing a String', function () {
        	expect(CryptoMan.parse(
          		JSON.parse('{"ct":"0e689437404192dc6c0b563e18bc48d8","iv":"f02f265e2f98f7889aa97898943726ee","s":"910d20bab84380fc"}'))
        	)
        	.toEqual(
          		{
            		ct: CryptoJS.enc.Hex.parse("0e689437404192dc6c0b563e18bc48d8"),
            		iv: CryptoJS.enc.Hex.parse("f02f265e2f98f7889aa97898943726ee"),
            		s: CryptoJS.enc.Hex.parse("910d20bab84380fc")
          		}
        	);
      	});

      it('If the key is 123456 new key should not be generated', function () {
        expect(CryptoMan.parse({key:passKey})).toEqual({
          key: CryptoJS.enc.Hex.parse(passKey)
        });
      });
    });

	describe('Encrypt/Decrypt Test: ', function() {

		xit('Should return encrypted data', function () {
			var args = CryptoMan.parse({
				key : '123456',
				iv  : 'abcd',
			});
			//Call the Encryption function in Angulars service instance
			var FactoryEncrypted = CryptoMan.encrypt('Hello There',args);
			var encrypted = CryptoJS.AES.encrypt(
				'Hello There',
				args.key,{
					iv:args.iv,
					mode: CryptoJS.mode.CBC,
                    padding: CryptoJS.pad.Pkcs7
				}
			);


			// The entire object as such cannot be checked for Equality, it'll give the 13-inch error
			//Check the ciphertext returned by the CryptoMan service is exactly equal 
			// to the Ciphertext generated by the encrypted object make sure the parameters are the same
			expect(encrypted.ciphertext.toString()).toEqual(FactoryEncrypted.ciphertext.toString());
			expect(encrypted.ciphertext.toString() === FactoryEncrypted.ciphertext.toString()).toBeTruthy();
		});

		it('Should encrypt and return decrypted data', function() {
			var args = CryptoMan.parse({
				key : CryptoMan.setKey(),
				iv : CryptoMan.getRand()
			});
			var encrypted = CryptoMan.encrypt('Hello There',args);
			console.log(encrypted);
			var decrypted = CryptoMan.decrypt({
				ct : encrypted.ct,
				key: args.key,
				iv: args.iv
			});
			// console.log(decrypted);
			expect(decrypted).toEqual('Hello There');
		});

		xit('Takes in Utf8 values, encrypts it and then successfully decrypts it', function() {
			var args = {
				key : CryptoMan.setKey(),
				iv  : CryptoMan.getRand()
			};

			var encrypted = CryptoMan.encrypt('Hello There',args);
			args.ct = Wrangler.getString(encrypted.ciphertext);
		
			expect(CryptoMan.decrypt(args)).toEqual('Hello There');
		});

		xit('Should receive UploadURL from the backed', function() {
			http.get('http://localhost:8080/rest/getBlobUploader').success(function(data) {
				console.log(data);
				expect(data).not.toBeUndefined()	
			});
		});

		it('Encrypts and Decrypts Blobs', function() {
			// START THE ENCRYPTION PROCEDURE
			
			var secureFileBlob; //Stores the Final encrypted file
			var secureFile;

			var file = 'Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor'+
				'incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud ' + 
				'exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure ' +
				'dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. '+
				'Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt ' +
				'mollit anim id est laborum.';
			// console.log(file);
			var fileBlob = new Blob([file], {type : 'text/plain'});

			var reader = new FileReader();

			reader.onloadend = function () {
				// Generate the key and iv
				var args = {
					key : CryptoMan.setKey(),
					iv  : CryptoMan.getRand()
				};
				// encrypt the read result
				var encrypted = CryptoMan.encrypt(reader.result, args);
				// console.log(encrypted.ct);
				// Proceed to creating Header by encrypting the key and iv used to encrypt the file
				var header = CryptoMan.encrypt({
					key: encrypted.key,
					iv: encrypted.iv
				},{
					key: passKey,
					iv: globalIV
				});
				// console.log('Length of header : ' + header.ct.length);
				// console.log(header.ct);
				secureFile = header.ct + encrypted.ct;
				/*secureFileBlob = new Blob([secureFile], {type: 'text/plain'});
				console.log('Size of the Final Blob : ' + secureFileBlob.size);*/
				
				// START THE DECRYPTION PROCEDURE OF THE SecureFileBlob

				var header = secureFile.slice(0,128);
				var encryptedFile = secureFile.slice(128, secureFile.length);
				// expect(encryptedFile).toEqual(encrypted.ct);
				// console.log(header);
				// console.log(encryptedFile);
				var decryptedHeader = JSON.parse(CryptoMan.decrypt({
					ct : header,
					key: passKey,
					iv: globalIV
				}));
				// expect(decryptedHeader).toEqual(args);
				// console.log(decryptedHeader);
				// decryptedHeader = JSON.parse(decryptedHeader);
				var decryptedFile = CryptoMan.decrypt({
					ct: encryptedFile,
					key: decryptedHeader.key,
					iv: decryptedHeader.iv
				});
				console.log(decryptedFile);
				// expect(decryptedFile).toEqual(file);

			};
			reader.readAsText(fileBlob,{type : 'text/plain'});
			
			
			
			
		});


	});
});

