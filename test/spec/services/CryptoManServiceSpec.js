'use strict';

xdescribe('Unit: CryptoMan', function() {
	var CryptoMan,
		passKey,
		Wrangler;

	beforeEach(function() {
		module('udecApp');

		inject(function($injector) {
				passKey = $injector.get('passKey');
			    CryptoMan = $injector.get('CryptoMan');
			    Wrangler = $injector.get('Wrangler');
			}
		);
	});

	it('Should Initialize', function() {
		expect(angular.isFunction(CryptoMan.getRand)).toBeTruthy();
		expect(angular.isFunction(CryptoMan.setKey)).toBeTruthy();
		expect(angular.isFunction(CryptoMan.encrypt)).toBeTruthy();
		expect(angular.isFunction(CryptoMan.decrypt)).toBeTruthy();
	});

	it('CryptoMan.getRand should return some Random value', function () {
		expect(CryptoMan.getRand()).not.toBeUndefined();
	});

	it('CryptoMan.setKey should return some Value', function() {
		expect(CryptoMan.setKey()).not.toBeUndefined();
	});

	describe('Checks for stringify',function () {
	    it('Should return a string', function () {
	        expect(typeof CryptoMan.stringify(CryptoJS.AES.encrypt('Some Message', 'some Key'))).toBe(typeof '');
	    });

		xit('Should return the Correct data', function () {
		    expect(CryptoMan.stringify(
		      CryptoJS.AES.encrypt('Some Message', 'some key')
		    )).toEqual('{"ct":"0e689437404192dc6c0b563e18bc48d8","iv":"f02f265e2f98f7889aa97898943726ee","s":"910d20bab84380fc"}');
		});
    });

    describe('Checks for parse', function () {
      	it('Should return an Object for passing a String', function () {
        	expect(CryptoMan.parse(
          		JSON.parse('{"ct":"0e689437404192dc6c0b563e18bc48d8","iv":"f02f265e2f98f7889aa97898943726ee","s":"910d20bab84380fc"}'))
        	)
        	.toEqual(
          		{
            		ct: CryptoJS.enc.Hex.parse("0e689437404192dc6c0b563e18bc48d8"),
            		iv: CryptoJS.enc.Hex.parse("f02f265e2f98f7889aa97898943726ee"),
            		s: CryptoJS.enc.Hex.parse("910d20bab84380fc")
          		}
        	);
      	});

      it('If the key is 123456 new key should not be generated', function () {
        expect(CryptoMan.parse({key:passKey})).toEqual({
          key: CryptoJS.enc.Hex.parse(passKey)
        });
      });
    });

	describe('Encrypt/Decrypt Test: ', function() {

		it('Should return encrypted data', function () {
			var args = CryptoMan.parse({
				key : '123456',
				iv  : 'abcd',
			});
			//Call the Encryption function in Angulars service instance
			var FactoryEncrypted = CryptoMan.encrypt('Hello There',args);
			var encrypted = CryptoJS.AES.encrypt(
				'Hello There',
				args.key,{
					iv:args.iv,
					mode: CryptoJS.mode.CBC,
                    padding: CryptoJS.pad.Pkcs7
				}
			);

			// The entire object as such cannot be checked for Equality, it'll give the 13-inch error
			//Check the ciphertext returned by the CryptoMan service is exactly equal 
			// to the Ciphertext generated by the encrypted object make sure the parameters are the same
			expect(encrypted.ciphertext.toString()).toEqual(FactoryEncrypted.ciphertext.toString());
			expect(encrypted.ciphertext.toString() === FactoryEncrypted.ciphertext.toString()).toBeTruthy();
		});

		it('Takes in Utf8 values, encrypts it and then successfully decrypts it', function() {
			var args = {
				key : CryptoMan.setKey(),
				iv  : CryptoMan.getRand()
			};

			var encrypted = CryptoMan.encrypt('Hello There',args);
			args.ct = Wrangler.getString(encrypted.ciphertext);
		
			expect(CryptoMan.decrypt(args)).toEqual('Hello There');
		});
	});
});